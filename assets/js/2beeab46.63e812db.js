(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{120:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return p})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return s}));var r=t(3),a=t(8),i=(t(0),t(280)),o={id:"finditer_function",title:"Finditer Function",sidebar_label:"15.5 Finditer Function",slug:"finditer_function",custom_edit_url:null},p={unversionedId:"python/module_re/finditer_function",id:"python/module_re/finditer_function",isDocsHomePage:!1,title:"Finditer Function",description:"Function finditer:",source:"@site/docs/python/module_re/5_finditer_function.md",slug:"/python/module_re/finditer_function",permalink:"/docs/python/module_re/finditer_function",editUrl:null,version:"current",sidebar_label:"15.5 Finditer Function",sidebar:"someSidebar",previous:{title:"Match Function",permalink:"/docs/python/module_re/match_function"},next:{title:"Findall Function",permalink:"/docs/python/module_re/findall_function"}},c=[{value:"Processing of \u2018show cdp neighbors detail\u2019 output",id:"processing-of-show-cdp-neighbors-detail-output",children:[]}],l={toc:c};function s(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Function ",Object(i.b)("inlineCode",{parentName:"p"},"finditer"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"is used to search for all non-overlapping matches in string"),Object(i.b)("li",{parentName:"ul"},"returns an iterator with Match objects"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"finditer")," returns iterator even if no match is found")),Object(i.b)("p",null,"Function ",Object(i.b)("inlineCode",{parentName:"p"},"finditer")," is well suited to handle those commands whose output is displayed by columns. For example: \u2018sh ip int br\u2019, \u2018sh mac address-table\u2019, etc. In this case it can be applied to the entire output of command."),Object(i.b)("p",null,"Example of \u2018sh ip int br\u2019 output:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [8]: sh_ip_int_br = '''\n   ...: R1#show ip interface brief\n   ...: Interface             IP-Address      OK? Method Status           Protocol\n   ...: FastEthernet0/0       15.0.15.1       YES manual up               up\n   ...: FastEthernet0/1       10.0.12.1       YES manual up               up\n   ...: FastEthernet0/2       10.0.13.1       YES manual up               up\n   ...: FastEthernet0/3       unassigned      YES unset  up               up\n   ...: Loopback0             10.1.1.1        YES manual up               up\n   ...: Loopback100           100.0.0.1       YES manual up               up\n   ...: '''\n")),Object(i.b)("p",null,"regex for output processing:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [9]: result = re.finditer(r'(\\S+) +'\n   ...:                      r'([\\d.]+) +'\n   ...:                      r'\\w+ +\\w+ +'\n   ...:                      r'(up|down|administratively down) +'\n   ...:                      r'(up|down)',\n   ...:                      sh_ip_int_br)\n   ...:\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"result")," variable contains an iterator:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [12]: result\nOut[12]: <callable_iterator at 0xb583f46c>\n")),Object(i.b)("p",null,"Iterator contains Match objects:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [16]: groups = []\n\nIn [18]: for match in result:\n    ...:     print(match)\n    ...:     groups.append(match.groups())\n    ...:\n<_sre.SRE_Match object; span=(103, 171), match='FastEthernet0/0       15.0.15.1       YES manual >\n<_sre.SRE_Match object; span=(172, 240), match='FastEthernet0/1       10.0.12.1       YES manual >\n<_sre.SRE_Match object; span=(241, 309), match='FastEthernet0/2       10.0.13.1       YES manual >\n<_sre.SRE_Match object; span=(379, 447), match='Loopback0             10.1.1.1        YES manual >\n<_sre.SRE_Match object; span=(448, 516), match='Loopback100           100.0.0.1       YES manual >'\n")),Object(i.b)("p",null,"Now in ",Object(i.b)("inlineCode",{parentName:"p"},"groups")," list there are tuples with strings that fallen into groups:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [19]: groups\nOut[19]:\n[('FastEthernet0/0', '15.0.15.1', 'up', 'up'),\n ('FastEthernet0/1', '10.0.12.1', 'up', 'up'),\n ('FastEthernet0/2', '10.0.13.1', 'up', 'up'),\n ('Loopback0', '10.1.1.1', 'up', 'up'),\n ('Loopback100', '100.0.0.1', 'up', 'up')]\n")),Object(i.b)("p",null,"A similar result can be obtained by a list comprehension:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [20]: regex = r'(\\S+) +([\\d.]+) +\\w+ +\\w+ +(up|down|administratively down) +(up|down)'\n\nIn [21]: result = [match.groups() for match in re.finditer(regex, sh_ip_int_br)]\n\nIn [22]: result\nOut[22]:\n[('FastEthernet0/0', '15.0.15.1', 'up', 'up'),\n ('FastEthernet0/1', '10.0.12.1', 'up', 'up'),\n ('FastEthernet0/2', '10.0.13.1', 'up', 'up'),\n ('Loopback0', '10.1.1.1', 'up', 'up'),\n ('Loopback100', '100.0.0.1', 'up', 'up')]\n")),Object(i.b)("p",null,"Now we will analyze the same log file that was used in ",Object(i.b)("inlineCode",{parentName:"p"},"search")," and ",Object(i.b)("inlineCode",{parentName:"p"},"match")," subsections."),Object(i.b)("p",null,"In this case it is possible to pass the entire contents of file (parse_log_finditer.py):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import re\n\nregex = (r'Host \\S+ '\n         r'in vlan (\\d+) '\n         r'is flapping between port '\n         r'(\\S+) and port (\\S+)')\n\nports = set()\n\nwith open('log.txt') as f:\n    for m in re.finditer(regex, f.read()):\n        vlan = m.group(1)\n        ports.add(m.group(2))\n        ports.add(m.group(3))\n\nprint('Loop between ports {} in VLAN {}'.format(', '.join(ports), vlan))\n")),Object(i.b)("p",null,"Warning"),Object(i.b)("p",null,"In real life, a log file can be very large. In that case, it\u2019s better to process it line by line."),Object(i.b)("p",null,"Output will be the same:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"$ python parse_log_finditer.py\nLoop between ports Gi0/19, Gi0/24, Gi0/16 \u0432 VLAN 10\n")),Object(i.b)("h2",{id:"processing-of-show-cdp-neighbors-detail-output"},"Processing of \u2018show cdp neighbors detail\u2019 output"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"finditer")," can handle output of \u2018sh cdp neighbors detail\u2019 as well as in re.search subsection."),Object(i.b)("p",null,"The script is almost identical to version with ",Object(i.b)("inlineCode",{parentName:"p"},"re.search")," (parse_sh_cdp_neighbors_detail_finditer.py file):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import re\nfrom pprint import pprint\n\n\ndef parse_cdp(filename):\n    regex = (r'Device ID: (?P<device>\\S+)'\n             r'|IP address: (?P<ip>\\S+)'\n             r'|Platform: (?P<platform>\\S+ \\S+),'\n             r'|Cisco IOS Software, (?P<ios>.+), RELEASE')\n\n    result = {}\n\n    with open(filename) as f:\n        match_iter = re.finditer(regex, f.read())\n        for match in match_iter:\n            if match.lastgroup == 'device':\n                device = match.group(match.lastgroup)\n                result[device] = {}\n            elif device:\n                result[device][match.lastgroup] = match.group(match.lastgroup)\n\n    return result\n\npprint(parse_cdp('sh_cdp_neighbors_sw1.txt'))\n")),Object(i.b)("p",null,"Now matches are searched throughout the file, not in every line separately:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"with open(filename) as f:\n    match_iter = re.finditer(regex, f.read())\n")),Object(i.b)("p",null,"Then matches go through the loop:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"with open(filename) as f:\n    match_iter = re.finditer(regex, f.read())\n    for match in match_iter:\n")),Object(i.b)("p",null,"The rest is the same."),Object(i.b)("p",null,"The result will be:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"$ python parse_sh_cdp_neighbors_detail_finditer.py\n{'R1': {'ios': '3800 Software (C3825-ADVENTERPRISEK9-M), Version 12.4(24)T1',\n        'ip': '10.1.1.1',\n        'platform': 'Cisco 3825'},\n 'R2': {'ios': '2900 Software (C3825-ADVENTERPRISEK9-M), Version 15.2(2)T1',\n        'ip': '10.2.2.2',\n        'platform': 'Cisco 2911'},\n 'SW2': {'ios': 'C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9',\n         'ip': '10.1.1.2',\n         'platform': 'cisco WS-C2960-8TC-L'}}\n")),Object(i.b)("p",null,"Although the result is similar, ",Object(i.b)("inlineCode",{parentName:"p"},"finditer")," has more features, as you can specify not only what should be in searched string but also in strings around it. For example, you can specify exactly which IP address to take:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"Device ID: SW2\nEntry address(es):\n  IP address: 10.1.1.2\nPlatform: cisco WS-C2960-8TC-L,  Capabilities: Switch IGMP\n\n...\n\nNative VLAN: 1\nDuplex: full\nManagement address(es):\n  IP address: 10.1.1.2\n")),Object(i.b)("p",null,"If you want to take the first IP address you can supplement a regex like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"regex = (r'Device ID: (?P<device>\\S+)'\n         r'|Entry address.*\\n +IP address: (?P<ip>\\S+)'\n         r'|Platform: (?P<platform>\\S+ \\S+),'\n         r'|Cisco IOS Software, (?P<ios>.+), RELEASE')\n")))}s.isMDXComponent=!0},280:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return m}));var r=t(0),a=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),s=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},u=function(e){var n=s(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},d=a.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=s(t),d=r,m=u["".concat(o,".").concat(d)]||u[d]||b[d]||i;return t?a.a.createElement(m,p(p({ref:n},l),{},{components:t})):a.a.createElement(m,p({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var p={};for(var c in n)hasOwnProperty.call(n,c)&&(p[c]=n[c]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var l=2;l<i;l++)o[l]=t[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);