(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{243:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var o=n(3),a=n(8),r=(n(0),n(281)),c={id:"tasks",title:"Tasks",sidebar_label:"Tasks",slug:"tasks",custom_edit_url:null},i={unversionedId:"python/modules/tasks",id:"python/modules/tasks",isDocsHomePage:!1,title:"Tasks",description:"All tasks and additional files can be downloaded from repository.",source:"@site/docs/python/modules/5_tasks.md",slug:"/python/modules/tasks",permalink:"/docs/python/modules/tasks",editUrl:null,version:"current",sidebar_label:"Tasks",sidebar:"someSidebar",previous:{title:"Further Reading",permalink:"/docs/python/modules/further_reading"},next:{title:"Subprocess",permalink:"/docs/python/useful_modules/subprocess"}},s=[{value:"Task 11.1",id:"task-111",children:[]},{value:"Task 11.2",id:"task-112",children:[]},{value:"Task 11.2a",id:"task-112a",children:[]}],l={toc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"All tasks and additional files can be downloaded from ",Object(r.b)("a",{parentName:"p",href:"https://github.com/natenka/pyneng-examples-exercises-en/"},"repository"),"."),Object(r.b)("p",null,"Warning"),Object(r.b)("p",null,"Starting from section \u201c4. Data types in Python\u201d there are automated tests for testing tasks. They help to check whether everything matches the task, and also give feedback on what does not correspond to the task. As a rule, after the first period of adaptation to tests, it becomes easier to do tasks with tests. Testing is done using the pyneng utility. ",Object(r.b)("a",{parentName:"p",href:"https://pyneng.readthedocs.io/en/latest/book/additional_info/pyneng.html#additional-info-pyneng"},"Learn more about how to work with the pyneng utility"),"."),Object(r.b)("h2",{id:"task-111"},"Task 11.1"),Object(r.b)("p",null,"Create a function parse_cdp_neighbors that handles show cdp neighbors command output."),Object(r.b)("p",null,"The function must have one parameter, command_output, which expects a single string of command output as an argument (not a filename). To do this, you need to read the entire contents of the file into a string, and then pass the string as an argument to the function (how to pass the command output is shown in the code below)."),Object(r.b)("p",null,"The function should return a dictionary that describes the connections between devices."),Object(r.b)("p",null,"For example, if the following output was passed as an argument:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"R4>show cdp neighbors\n\nDevice ID    Local Intrfce   Holdtme     Capability       Platform    Port ID\nR5           Fa 0/1          122           R S I           2811       Fa 0/1\nR6           Fa 0/2          143           R S I           2811       Fa 0/0\n")),Object(r.b)("p",null,"Function should return a dictionary:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{("R4", "Fa0/1"): ("R5", "Fa0/1"),\n ("R4", "Fa0/2"): ("R6", "Fa0/0")}\n')),Object(r.b)("p",null,"In the dictionary, interfaces must be written without a space between type and name. That is, so Fa0/0, and not so Fa 0/0."),Object(r.b)("p",null,"Check the operation of the function on the contents of the sh_cdp_n_sw1.txt file. In this case, the function should work on other files (the test checks the operation of the function on the output from sh_cdp_n_sw1.txt and sh_cdp_n_r3.txt)."),Object(r.b)("p",null,"Restriction: All tasks must be done using the topics covered in this and previous chapters."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'def parse_cdp_neighbors(command_output):\n    """\n    Here we pass the output of the command as single string because it is in this\n    form that received command output from equipment. Taking the output of\n    the command as an argument, instead of a filename, we make the function more\n    generic: it can work both with files and with output from equipment.\n    Plus, we learn to work with such a output.\n    """\n\n\nif __name__ == "__main__":\n    with open("sh_cdp_n_sw1.txt") as f:\n        print(parse_cdp_neighbors(f.read()))\n')),Object(r.b)("h2",{id:"task-112"},"Task 11.2"),Object(r.b)("p",null,"Create a create_network_map function that processes the show cdp neighbors command output from multiple files and merges it into one common topology."),Object(r.b)("p",null,"The function must have one parameter, filenames, which expects as an argument a list of filenames containing the output of the show cdp neighbors command."),Object(r.b)("p",null,"The function should return a dictionary that describes the connections between devices. The structure of the dictionary is the same as in task 11.1:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{("R4", "Fa0/1"): ("R5", "Fa0/1"),\n ("R4", "Fa0/2"): ("R6", "Fa0/0")}\n')),Object(r.b)("p",null,"Generate topology that matches the output from the files:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_sw1.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r1.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r2.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r3.txt")),Object(r.b)("p",null,"Do not copy the code of the parse_cdp_neighbors and draw_topology functions. If the parse_cdp_neighbors function cannot process the output of one of the command output files, you need to correct the function code in task 11.1."),Object(r.b)("p",null,"Restriction: All tasks must be done using the topics covered in this and previous chapters."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'infiles = [\n    "sh_cdp_n_sw1.txt",\n    "sh_cdp_n_r1.txt",\n    "sh_cdp_n_r2.txt",\n    "sh_cdp_n_r3.txt",\n]\n')),Object(r.b)("h2",{id:"task-112a"},"Task 11.2a"),Object(r.b)("p",null,"Note"),Object(r.b)("p",null,"To complete this task, graphviz must be installed: apt-get install graphviz"),Object(r.b)("p",null,"And a python module to work with graphviz: pip install graphviz"),Object(r.b)("p",null,"Use the create_network_map function from task 11.2 to create the topology dict for files:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_sw1.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r1.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r2.txt"),Object(r.b)("li",{parentName:"ul"},"sh_cdp_n_r3.txt")),Object(r.b)("p",null,"Using the draw_topology function from the draw_network_graph.py file, draw schema for the topology dict received with create_network_map function. You need to figure out how to work with the draw_topology function on your own, by reading the function description in the draw_network_graph.py file. The resulting scheme will be written to the svg file - it can be opened with a browser."),Object(r.b)("p",null,"With the current topology dictionary, extra connections are drawn on the diagram. They occur because one CDP file (sh_cdp_n_r1.txt) describes connection ",Object(r.b)("inlineCode",{parentName:"p"},'("R1", "Eth0/0"): ("SW1", "Eth0/1")')," and another (sh_cdp_n_sw1.txt) describes connection ",Object(r.b)("inlineCode",{parentName:"p"},'("SW1", "Eth0/1"): ("R1", "Eth0/0")'),"."),Object(r.b)("p",null,"In this task, you need to create a new function unique_network_map, which of these two connections will leave only one, for correct drawing of the schema. In this case, it does not matter which of the connections to leave."),Object(r.b)("p",null,"The unique_network_map function must have one topology_dict parameter, which expects a dictionary as an argument. It should be a dictionary resulting from the create_network_map function call."),Object(r.b)("p",null,"Dict example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{\n    ("R1", "Eth0/0"): ("SW1", "Eth0/1"),\n    ("R2", "Eth0/0"): ("SW1", "Eth0/2"),\n    ("R2", "Eth0/1"): ("SW2", "Eth0/11"),\n    ("R3", "Eth0/0"): ("SW1", "Eth0/3"),\n    ("R3", "Eth0/1"): ("R4", "Eth0/0"),\n    ("R3", "Eth0/2"): ("R5", "Eth0/0"),\n    ("SW1", "Eth0/1"): ("R1", "Eth0/0"),\n    ("SW1", "Eth0/2"): ("R2", "Eth0/0"),\n    ("SW1", "Eth0/3"): ("R3", "Eth0/0"),\n    ("SW1", "Eth0/5"): ("R6", "Eth0/1"),\n}\n')),Object(r.b)("p",null,"The function should return a dictionary that describes the connections between devices. In the dictionary, you need to get rid of \u201cduplicate\u201d connections and leave only one of them."),Object(r.b)("p",null,"The structure of the final dict is the same as in task 11.2:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{("R4", "Fa0/1"): ("R5", "Fa0/1"),\n ("R4", "Fa0/2"): ("R6", "Fa0/0")}\n')),Object(r.b)("p",null,"After creating the function, try drawing the topology again, now for the dictionary returned by the unique_network_map function."),Object(r.b)("p",null,"The result should look the same as the diagram in task_11_2a_topology.svg"),Object(r.b)("p",null,Object(r.b)("img",{parentName:"p",src:"https://raw.githubusercontent.com/natenka/pyneng-examples-exercises-en/master/exercises/11_modules/task_11_2a_topology.png",alt:"https://raw.githubusercontent.com/natenka/pyneng-examples-exercises-en/master/exercises/11_modules/task_11_2a_topology.png"})),Object(r.b)("p",null,"Wherein:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The arrangement of devices on the diagram may be different"),Object(r.b)("li",{parentName:"ul"},"Connections must match the diagram")),Object(r.b)("p",null,"Do not copy the code of the create_network_map and draw_topology functions."),Object(r.b)("p",null,"Restriction: All tasks must be done using the topics covered in this and previous chapters."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'infiles = [\n    "sh_cdp_n_sw1.txt",\n    "sh_cdp_n_r1.txt",\n    "sh_cdp_n_r2.txt",\n    "sh_cdp_n_r3.txt",\n]\n')))}p.isMDXComponent=!0},281:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,b=u["".concat(c,".").concat(d)]||u[d]||h[d]||r;return n?a.a.createElement(b,i(i({ref:t},l),{},{components:n})):a.a.createElement(b,i({ref:t},l))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,c=new Array(r);c[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,c[1]=i;for(var l=2;l<r;l++)c[l]=n[l];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);