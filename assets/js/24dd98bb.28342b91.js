(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{104:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return u}));var o=t(3),i=t(8),r=(t(0),t(281)),a={id:"module_concurrent_futures",title:"Module Concurrent.Futures",sidebar_label:"Module Concurrent.Futures",slug:"module_concurrent_futures",custom_edit_url:null},c={unversionedId:"python/19_concurrent_connections/module_concurrent_futures",id:"python/19_concurrent_connections/module_concurrent_futures",isDocsHomePage:!1,title:"Module Concurrent.Futures",description:"Module concurrent.futures provides a high-level interface for working with processes and threads. For both threads and processes the same interface is used which makes it easy to switch between them.",source:"@site/docs/python/19_concurrent_connections/6_module_concurrent_futures.md",slug:"/python/19_concurrent_connections/module_concurrent_futures",permalink:"/docs/python/19_concurrent_connections/module_concurrent_futures",editUrl:null,version:"current",sidebar_label:"Module Concurrent.Futures",sidebar:"someSidebar",previous:{title:"Module Logging",permalink:"/docs/python/19_concurrent_connections/module_logging"},next:{title:"Further Reading",permalink:"/docs/python/19_concurrent_connections/further_reading"}},s=[{value:"Map exception handling",id:"map-exception-handling",children:[]},{value:"Future",id:"future",children:[]},{value:"Processing of exceptions",id:"processing-of-exceptions",children:[]},{value:"Method map",id:"method-map-1",children:[]},{value:"Method submit",id:"method-submit",children:[]}],d={toc:s};function u(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Module ",Object(r.b)("inlineCode",{parentName:"p"},"concurrent.futures")," provides a high-level interface for working with processes and threads. For both threads and processes the same interface is used which makes it easy to switch between them."),Object(r.b)("p",null,"If you compare this module with threading or multiprocessing, it has fewer features but with ",Object(r.b)("inlineCode",{parentName:"p"},"concurrent.futures")," it\u2019s easier to work and interface easier to understand."),Object(r.b)("p",null,"Concurrent.futures module allows to solve the problem of starting multiple threads/processes and getting data from them. For this purpose, module uses two classes:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ThreadPoolExecutor")," - for threads handling"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ProcessPoolExecutor")," - for process handling")),Object(r.b)("p",null,"Both classes use the same interface, so it is enough to deal with one and then just switch to other if necessary."),Object(r.b)("p",null,"Create an Executor object using ThreadPoolExecutor:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"executor = ThreadPoolExecutor(max_workers=5)\n")),Object(r.b)("p",null,"After creating an Executor object, it has three methods: ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown"),", ",Object(r.b)("inlineCode",{parentName:"p"},"map"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"submit"),". Method ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," is responsible for the completion of threads/processes, ",Object(r.b)("inlineCode",{parentName:"p"},"map")," and ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," methods are responsible for starting functions in different threads/processes."),Object(r.b)("p",null,"Note"),Object(r.b)("p",null,"In fact, map and submit can run not only functions but any callable object. However, only functions will be covered further."),Object(r.b)("p",null,"Method ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," indicates that Executor object must be finished. However, if to ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," method pass ",Object(r.b)("inlineCode",{parentName:"p"},"wait=True")," (default value), it will not return the result until all functions running in threads have been completed. If ",Object(r.b)("inlineCode",{parentName:"p"},"wait=False"),", ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," method returns instantly but script itself will not exit until all functions have been completed."),Object(r.b)("p",null,"Generally, ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," is not explicitly used because when creating an Executor object in a context manager, ",Object(r.b)("inlineCode",{parentName:"p"},"shutdown")," is automatically called at the end of a block with ",Object(r.b)("inlineCode",{parentName:"p"},"wait=True"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"with ThreadPoolExecutor(max_workers=5) as executor:\n    ...\n")),Object(r.b)("p",null,"Since map and submit methods start a function in threads or processes, code must at least have a function that performs one action and must be run in different threads with different arguments of the function."),Object(r.b)("p",null,"For example, if you need to ping multiple IP addresses in different threads you need to create a function that pings one IP address and then run this function in different threads for different IP addresses using concurrent.futures."),Object(r.b)("h1",{id:"method-map"},"Method map"),Object(r.b)("p",null,"Method syntax:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"map(func, *iterables, timeout=None)\n")),Object(r.b)("p",null,"Method ",Object(r.b)("inlineCode",{parentName:"p"},"map")," is similar to built-in map function: applying ",Object(r.b)("inlineCode",{parentName:"p"},"func")," function to one or more iterable objects. Each call to a function is then started in a separate thread/process. Method ",Object(r.b)("inlineCode",{parentName:"p"},"map")," returns an iterator with function results for each element of object being iterated. The results are arranged in the same order as elements in iterable object."),Object(r.b)("p",null,"When working with thread/process pools, a certain number of threads/processes are created and the code is executed in these threads. For example, if the pool is created with 5 threads and function has to be started for 10 different devices, connection will be performed first to the first five devices and then, as they liberated, to the others."),Object(r.b)("p",null,"An example of using a ",Object(r.b)("inlineCode",{parentName:"p"},"map")," function with ThreadPoolExecutor (netmiko_threads_map_basics.py file):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from datetime import datetime\nimport time\nfrom itertools import repeat\nfrom concurrent.futures import ThreadPoolExecutor\nimport logging\n\nimport netmiko\nimport yaml\n\n\nlogging.getLogger('paramiko').setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\n\ndef send_show(device, show):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received:   {}'\n    ip = device['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1':\n        time.sleep(5)\n\n    with netmiko.ConnectHandler(**device) as ssh:\n        ssh.enable()\n        result = ssh.send_command(show)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n        return result\n\n\nwith open('devices.yaml') as f:\n    devices = yaml.safe_load(f)\n\nwith ThreadPoolExecutor(max_workers=3) as executor:\n    result = executor.map(send_show, devices, repeat('sh clock'))\n    for device, output in zip(devices, result):\n        print(device['host'], output)\n")),Object(r.b)("p",null,"Since function should be passed to ",Object(r.b)("inlineCode",{parentName:"p"},"map")," method, ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function is created which connects to devices, passes specified show command and returns the result with command output."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"def send_show(device, show):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received:   {}'\n    ip = device['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1':\n        time.sleep(5)\n\n    with netmiko.ConnectHandler(**device) as ssh:\n        ssh.enable()\n        result = ssh.send_command(show)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n        return result\n")),Object(r.b)("p",null,"Function ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," outputs log message at the beginning and at the end of work. This will determine when function has worked for the particular device. Also within function it is specified that when connecting to device with address 192.168.100.1, the pause for 5 seconds is required - thus router with this address will respond longer."),Object(r.b)("p",null,"Last 4 lines of code are responsible for connecting to devices in separate threads:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"with ThreadPoolExecutor(max_workers=3) as executor:\n    result = executor.map(send_show, devices, repeat('sh clock'))\n    for device, output in zip(devices, result):\n        print(device['host'], output)\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"with ThreadPoolExecutor(max_workers=3) as executor:")," - ThreadPoolExecutor class is initiated in ",Object(r.b)("inlineCode",{parentName:"p"},"with")," block with indicated number of threads.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"},"result = executor.map(send_show, devices, repeat('sh clock'))\n")))),Object(r.b)("p",null,"  ","-"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"map\n")),Object(r.b)("p",null,"  method is similar to"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"map\n")),Object(r.b)("p",null,"  function, but here the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"send_show\n")),Object(r.b)("p",null,"  function is called in different threads. However, in different threads the function will be called with different arguments:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"elements of iterable object ",Object(r.b)("inlineCode",{parentName:"p"},"devices")," and the same command \u201csh clock\u201d.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"since instead of a list of commands only one command is used, it must be repeated in some way, so that ",Object(r.b)("inlineCode",{parentName:"p"},"map")," method will set this command to different devices. It uses ",Object(r.b)("inlineCode",{parentName:"p"},"repeat")," function - it repeats command exactly as many times as ",Object(r.b)("inlineCode",{parentName:"p"},"map")," requests")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"map")," method returns generator. This generator contains results of functions. Results are in the same order as devices in the list of devices, so ",Object(r.b)("inlineCode",{parentName:"p"},"zip")," function is used to combine device IP addresses and command output."))),Object(r.b)("p",null,"Execution result:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_threads_map_basics.py\nThreadPoolExecutor-0_0 root INFO: ===> 08:28:55.950254 Connection: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: ===> 08:28:55.963198 Connection: 192.168.100.2\nThreadPoolExecutor-0_2 root INFO: ===> 08:28:55.970269 Connection: 192.168.100.3\nThreadPoolExecutor-0_1 root INFO: <=== 08:29:11.968796 Received:   192.168.100.2\nThreadPoolExecutor-0_2 root INFO: <=== 08:29:15.497324 Received:   192.168.100.3\nThreadPoolExecutor-0_0 root INFO: <=== 08:29:16.854344 Received:   192.168.100.1\n192.168.100.1 *08:29:16.663 UTC Thu Jul 4 2019\n192.168.100.2 *08:29:11.744 UTC Thu Jul 4 2019\n192.168.100.3 *08:29:15.374 UTC Thu Jul 4 2019\n")),Object(r.b)("p",null,"The first three messages indicate when connection was made and to which device:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"ThreadPoolExecutor-0_0 root INFO: ===> 08:28:55.950254 Connection: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: ===> 08:28:55.963198 Connection: 192.168.100.2\nThreadPoolExecutor-0_2 root INFO: ===> 08:28:55.970269 Connection: 192.168.100.3\n")),Object(r.b)("p",null,"The following three messages show time of receipt of information and completion of the function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"ThreadPoolExecutor-0_1 root INFO: <=== 08:29:11.968796 Received:   192.168.100.2\nThreadPoolExecutor-0_2 root INFO: <=== 08:29:15.497324 Received:   192.168.100.3\nThreadPoolExecutor-0_0 root INFO: <=== 08:29:16.854344 Received:   192.168.100.1\n")),Object(r.b)("p",null,"Since ",Object(r.b)("inlineCode",{parentName:"p"},"sleep")," was added for the first device for 5 seconds, information from the first router was actually received later. However, since ",Object(r.b)("inlineCode",{parentName:"p"},"map")," method returns values in the same order as devices in ",Object(r.b)("inlineCode",{parentName:"p"},"device")," list, the result is:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"192.168.100.1 *08:29:16.663 UTC Thu Jul 4 2019\n192.168.100.2 *08:29:11.744 UTC Thu Jul 4 2019\n192.168.100.3 *08:29:15.374 UTC Thu Jul 4 2019\n")),Object(r.b)("h2",{id:"map-exception-handling"},"Map exception handling"),Object(r.b)("p",null,"Example of ",Object(r.b)("inlineCode",{parentName:"p"},"map")," with exception handling:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ThreadPoolExecutor\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nfrom itertools import repeat\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler, NetMikoAuthenticationException\n\n\nlogging.getLogger('paramiko').setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\n\ndef send_show(device_dict, command):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received:   {}'\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1': time.sleep(5)\n\n    try:\n        with ConnectHandler(**device_dict) as ssh:\n            ssh.enable()\n            result = ssh.send_command(command)\n            logging.info(received_msg.format(datetime.now().time(), ip))\n        return result\n    except NetMikoAuthenticationException as err:\n        logging.warning(err)\n\n\ndef send_command_to_devices(devices, command):\n    data = {}\n    with ThreadPoolExecutor(max_workers=2) as executor:\n        result = executor.map(send_show, devices, repeat(command))\n        for device, output in zip(devices, result):\n            data[device['host']] = output\n    return data\n\n\nif __name__ == '__main__':\n    with open('devices.yaml') as f:\n        devices = yaml.safe_load(f)\n    pprint(send_command_to_devices(devices, 'sh ip int br'))\n")),Object(r.b)("p",null,"Example is generally similar to the previous one but NetMikoAuthenticationException was introduced in ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function, and the code that started ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function in threads is now in ",Object(r.b)("inlineCode",{parentName:"p"},"send_command_to_devices")," function."),Object(r.b)("p",null,"When using ",Object(r.b)("inlineCode",{parentName:"p"},"map")," method, exception handling is best done within a function that runs in threads, in this case ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function."),Object(r.b)("h1",{id:"method-submit-and-work-with-futures"},"Method submit and work with futures"),Object(r.b)("p",null,"Method ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," differs from ",Object(r.b)("inlineCode",{parentName:"p"},"map")," method:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," runs only one function in thread")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," can run different functions with different unrelated arguments, when ",Object(r.b)("inlineCode",{parentName:"p"},"map")," must run with iterable objects as arguments")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," immediately returns the result without having to wait for function execution")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"},"submit\n")))),Object(r.b)("p",null,"  returns special Future object that represents execution of function."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," returns Future in order that the call of ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," does not block the code. Once ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," has returned Future, code can be executed further. And once all functions in threads are running, you can start requesting Future if results are ready. Or take advantage of special function ",Object(r.b)("inlineCode",{parentName:"p"},"as_completed"),", which requests the result itself and code gets it when it\u2019s ready")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," returns results in readiness order, not in argument order")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," can pass key arguments when ",Object(r.b)("inlineCode",{parentName:"p"},"map")," only position arguments"))),Object(r.b)("p",null,"Method ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," uses ",Object(r.b)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Futures_and_promises"},"Future")," object - an object that represents a delayed computation. This object can be requested for status (completed or not), and results or exceptions can be obtained from the job. Future does not need to be created manually, these objects are created by ",Object(r.b)("inlineCode",{parentName:"p"},"submit"),"."),Object(r.b)("p",null,"Example of running a function in threads using ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," (netmiko_threads_submit_basics.py file)"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler, NetMikoAuthenticationException\n\n\nlogging.getLogger(\"paramiko\").setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\n\ndef send_show(device_dict, command):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received: {}'\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1':\n        time.sleep(5)\n\n    with ConnectHandler(**device_dict) as ssh:\n        ssh.enable()\n        result = ssh.send_command(command)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n    return {ip: result}\n\n\nwith open('devices.yaml') as f:\n    devices = yaml.safe_load(f)\n\nwith ThreadPoolExecutor(max_workers=2) as executor:\n    future_list = []\n    for device in devices:\n        future = executor.submit(send_show, device, 'sh clock')\n        future_list.append(future)\n    # the same in the form of list comprehensions:\n    # future_list = [executor.submit(send_show, device, 'sh clock') for device in devices]\n    for f in as_completed(future_list):\n        print(f.result())\n")),Object(r.b)("p",null,"The rest of the code has not changed, so you only need to understand the block which runs ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function in threads:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"with ThreadPoolExecutor(max_workers=2) as executor:\n    future_list = []\n    for device in devices:\n        future = executor.submit(send_show, device, 'sh clock')\n        future_list.append(future)\n    for f in as_completed(future_list):\n        print(f.result())\n")),Object(r.b)("p",null,"The rest of the code has not changed, so only block that runs ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," needs an attention:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"with ThreadPoolExecutor(max_workers=2) as executor:\n    future_list = []\n    for device in devices:\n        future = executor.submit(send_show, device, 'sh clock')\n        future_list.append(future)\n    for f in as_completed(future_list):\n        print(f.result())\n")),Object(r.b)("p",null,"Now block ",Object(r.b)("inlineCode",{parentName:"p"},"with")," has two cycles:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"},"future_list\n")))),Object(r.b)("p",null,"  ","-"," a list of Future objects:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," function is used to create Future object")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"submit")," expects the name of function to be executed and its arguments")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"the next cycle runs through future_list using ",Object(r.b)("inlineCode",{parentName:"p"},"as_completed")," function. This function returns a Future objects only when they have finished or been cancelled. Future is then returned as soon as work is completed, not in the order of adding to future_list"))),Object(r.b)("p",null,"Note"),Object(r.b)("p",null,"Creation of list with Future can be done with list comprehensions: ",Object(r.b)("inlineCode",{parentName:"p"},"future_list = [executor.submit(send_show, device, 'sh clock') for device in devices]")),Object(r.b)("p",null,"The result is:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_threads_submit_basics.py\nThreadPoolExecutor-0_0 root INFO: ===> 17:32:59.088025 Connection: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: ===> 17:32:59.094103 Connection: 192.168.100.2\nThreadPoolExecutor-0_1 root INFO: <=== 17:33:11.639672 Received: 192.168.100.2\n{'192.168.100.2': '*17:33:11.429 UTC Thu Jul 4 2019'}\nThreadPoolExecutor-0_1 root INFO: ===> 17:33:11.849132 Connection: 192.168.100.3\nThreadPoolExecutor-0_0 root INFO: <=== 17:33:17.735761 Received: 192.168.100.1\n{'192.168.100.1': '*17:33:17.694 UTC Thu Jul 4 2019'}\nThreadPoolExecutor-0_1 root INFO: <=== 17:33:23.230123 Received: 192.168.100.3\n{'192.168.100.3': '*17:33:23.188 UTC Thu Jul 4 2019'}\n")),Object(r.b)("p",null,"Please note that the order is not preserved and depends on which function was previously completed."),Object(r.b)("h2",{id:"future"},"Future"),Object(r.b)("p",null,"An example of running ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function with ",Object(r.b)("inlineCode",{parentName:"p"},"submit")," and displaying information about Future (note the status of Future at different points in time):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-python"},"In [1]: from concurrent.futures import ThreadPoolExecutor\n\nIn [2]: from netmiko_threads_submit_futures import send_show\n\nIn [3]: executor = ThreadPoolExecutor(max_workers=2)\n\nIn [4]: f1 = executor.submit(send_show, r1, 'sh clock')\n   ...: f2 = executor.submit(send_show, r2, 'sh clock')\n   ...: f3 = executor.submit(send_show, r3, 'sh clock')\n   ...:\nThreadPoolExecutor-0_0 root INFO: ===> 17:53:19.656867 Connection: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: ===> 17:53:19.657252 Connection: 192.168.100.2\n\nIn [5]: print(f1, f2, f3, sep='\\n')\n<Future at 0xb488e2ac state=running>\n<Future at 0xb488ef2c state=running>\n<Future at 0xb488e72c state=pending>\n\nThreadPoolExecutor-0_1 root INFO: <=== 17:53:25.757704 Received: 192.168.100.2\nThreadPoolExecutor-0_1 root INFO: ===> 17:53:25.869368 Connection: 192.168.100.3\n\nIn [6]: print(f1, f2, f3, sep='\\n')\n<Future at 0xb488e2ac state=running>\n<Future at 0xb488ef2c state=finished returned dict>\n<Future at 0xb488e72c state=running>\n\nThreadPoolExecutor-0_0 root INFO: <=== 17:53:30.431207 Received: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: <=== 17:53:31.636523 Received: 192.168.100.3\n\nIn [7]: print(f1, f2, f3, sep='\\n')\n<Future at 0xb488e2ac state=finished returned dict>\n<Future at 0xb488ef2c state=finished returned dict>\n<Future at 0xb488e72c state=finished returned dict>\n")),Object(r.b)("p",null,"In order to look at Future, several lines with information output are added to the script (netmiko_threads_submit_futures.py):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler, NetMikoAuthenticationException\n\n\nlogging.getLogger(\"paramiko\").setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\n\ndef send_show(device_dict, command):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received: {}'\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1':\n        time.sleep(5)\n\n    with ConnectHandler(**device_dict) as ssh:\n        ssh.enable()\n        result = ssh.send_command(command)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n    return {ip: result}\n\n\ndef send_command_to_devices(devices, command):\n    data = {}\n    with ThreadPoolExecutor(max_workers=2) as executor:\n        future_list = []\n        for device in devices:\n            future = executor.submit(send_show, device, command)\n            future_list.append(future)\n            print('Future: {} for device {}'.format(future, device['host']))\n        for f in as_completed(future_list):\n            result = f.result()\n            print('Future done {}'.format(f))\n            data.update(result)\n    return data\n\n\nif __name__ == '__main__':\n    with open('devices.yaml') as f:\n        devices = yaml.safe_load(f)\n    pprint(send_command_to_devices(devices, 'sh clock'))\n")),Object(r.b)("p",null,"The result is:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_threads_submit_futures.py\nFuture: <Future at 0xb5ed938c state=running> for device 192.168.100.1\nThreadPoolExecutor-0_0 root INFO: ===> 07:14:26.298007 Connection: 192.168.100.1\nFuture: <Future at 0xb5ed96cc state=running> for device 192.168.100.2\nFuture: <Future at 0xb5ed986c state=pending> for device 192.168.100.3\nThreadPoolExecutor-0_1 root INFO: ===> 07:14:26.299095 Connection: 192.168.100.2\nThreadPoolExecutor-0_1 root INFO: <=== 07:14:32.056003 Received: 192.168.100.2\nThreadPoolExecutor-0_1 root INFO: ===> 07:14:32.164774 Connection: 192.168.100.3\nFuture done <Future at 0xb5ed96cc state=finished returned dict>\nThreadPoolExecutor-0_0 root INFO: <=== 07:14:36.714923 Received: 192.168.100.1\nFuture done <Future at 0xb5ed938c state=finished returned dict>\nThreadPoolExecutor-0_1 root INFO: <=== 07:14:37.577327 Received: 192.168.100.3\nFuture done <Future at 0xb5ed986c state=finished returned dict>\n{'192.168.100.1': '*07:14:36.546 UTC Fri Jul 26 2019',\n '192.168.100.2': '*07:14:31.865 UTC Fri Jul 26 2019',\n '192.168.100.3': '*07:14:37.413 UTC Fri Jul 26 2019'}\n")),Object(r.b)("p",null,"Since two threads are used by default, only two out of three Future shows running status. The third is in pending state and is waiting for queue to arrive."),Object(r.b)("h2",{id:"processing-of-exceptions"},"Processing of exceptions"),Object(r.b)("p",null,"If there is an exception in function execution, it will be generated when the result is obtained For example, in device.yaml file the password for device 192.168.100.2 was changed to the wrong one:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'$ python netmiko_threads_submit.py\n===> 06:29:40.871851 Connection to device: 192.168.100.1\n===> 06:29:40.872888 Connection to device: 192.168.100.2\n===> 06:29:43.571296 Connection to device: 192.168.100.3\n<=== 06:29:48.921702 Received result from device: 192.168.100.3\n<=== 06:29:56.269284 Received result from device: 192.168.100.1\nTraceback (most recent call last):\n...\n  File "/home/vagrant/venv/py3_convert/lib/python3.6/site-packages/netmiko/base_connection.py", line 500, in establish_connection\n    raise NetMikoAuthenticationException(msg)\nnetmiko.ssh_exception.NetMikoAuthenticationException: Authentication failure: unable to connect cisco_ios 192.168.100.2:22\nAuthentication failed.\n')),Object(r.b)("p",null,"Since an exception occurs when result is obtained, it is easy to add exception processing (netmiko_threads_submit_exception.py file):"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ThreadPoolExecutor, as_completed\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nfrom itertools import repeat\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler\nfrom netmiko.ssh_exception import NetMikoAuthenticationException\n\nlogging.getLogger(\"paramiko\").setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\nstart_msg = '===> {} Connection: {}'\nreceived_msg = '<=== {} Received: {}'\n\n\ndef send_show(device_dict, command):\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1': time.sleep(5)\n    with ConnectHandler(**device_dict) as ssh:\n        ssh.enable()\n        result = ssh.send_command(command)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n    return {ip: result}\n\n\ndef send_command_to_devices(devices, command):\n    data = {}\n    with ThreadPoolExecutor(max_workers=2) as executor:\n        future_ssh = [\n            executor.submit(send_show, device, command) for device in devices\n        ]\n        for f in as_completed(future_ssh):\n            try:\n                result = f.result()\n            except NetMikoAuthenticationException as e:\n                print(e)\n            else:\n                data.update(result)\n    return data\n\n\nif __name__ == '__main__':\n    with open('devices.yaml') as f:\n        devices = yaml.safe_load(f)\n    pprint(send_command_to_devices(devices, 'sh clock'))\n")),Object(r.b)("p",null,"The result is:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_threads_submit_exception.py\nThreadPoolExecutor-0_0 root INFO: ===> 07:21:21.190544 Connection: 192.168.100.1\nThreadPoolExecutor-0_1 root INFO: ===> 07:21:21.191429 Connection: 192.168.100.2\nThreadPoolExecutor-0_1 root INFO: ===> 07:21:23.672425 Connection: 192.168.100.3\nAuthentication failure: unable to connect cisco_ios 192.168.100.2:22\nAuthentication failed.\nThreadPoolExecutor-0_1 root INFO: <=== 07:21:29.095289 Received: 192.168.100.3\nThreadPoolExecutor-0_0 root INFO: <=== 07:21:31.607635 Received: 192.168.100.1\n{'192.168.100.1': '*07:21:31.436 UTC Fri Jul 26 2019',\n '192.168.100.3': '*07:21:28.930 UTC Fri Jul 26 2019'}\n")),Object(r.b)("p",null,"Of course, exception handling can be performed within ",Object(r.b)("inlineCode",{parentName:"p"},"send_show")," function, but it is just an example of how you can work with exceptions when using a Future."),Object(r.b)("h1",{id:"using-processpoolexecutor"},"Using ProcessPoolExecutor"),Object(r.b)("p",null,"Interface of concurrent.futures module is very convenient because migration from threads to processes is done by replacing ThreadPoolExecutor with ProcessPoolExecutor, so all examples below are completely similar to examples with threads."),Object(r.b)("h2",{id:"method-map-1"},"Method map"),Object(r.b)("p",null,"To use processes instead of threads, it is sufficient to change ThreadPoolExecutor to ProcessPoolExecutor:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ProcessPoolExecutor\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nfrom itertools import repeat\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler, NetMikoAuthenticationException\n\n\nlogging.getLogger('paramiko').setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\n\ndef send_show(device_dict, command):\n    start_msg = '===> {} Connection: {}'\n    received_msg = '<=== {} Received:   {}'\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1': time.sleep(5)\n\n    try:\n        with ConnectHandler(**device_dict) as ssh:\n            ssh.enable()\n            result = ssh.send_command(command)\n            logging.info(received_msg.format(datetime.now().time(), ip))\n        return result\n    except NetMikoAuthenticationException as err:\n        logging.warning(err)\n\n\ndef send_command_to_devices(devices, command):\n    data = {}\n    with ProcessPoolExecutor(max_workers=2) as executor:\n        result = executor.map(send_show, devices, repeat(command))\n        for device, output in zip(devices, result):\n            data[device['host']] = output\n    return data\n\n\nif __name__ == '__main__':\n    with open('devices.yaml') as f:\n        devices = yaml.safe_load(f)\n    pprint(send_command_to_devices(devices, 'sh clock'))\n")),Object(r.b)("p",null,"Result of execution:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_processes_map.py\nMainThread root INFO: ===> 08:35:50.931629 Connection: 192.168.100.2\nMainThread root INFO: ===> 08:35:50.931295 Connection: 192.168.100.1\nMainThread root INFO: <=== 08:35:56.353774 Received:   192.168.100.2\nMainThread root INFO: ===> 08:35:56.469854 Connection: 192.168.100.3\nMainThread root INFO: <=== 08:36:01.410230 Received:   192.168.100.1\nMainThread root INFO: <=== 08:36:02.067678 Received:   192.168.100.3\n{'192.168.100.1': '*08:36:01.242 UTC Fri Jul 26 2019',\n '192.168.100.2': '*08:35:56.185 UTC Fri Jul 26 2019',\n '192.168.100.3': '*08:36:01.900 UTC Fri Jul 26 2019'}\n")),Object(r.b)("h2",{id:"method-submit"},"Method submit"),Object(r.b)("p",null,"File netmiko_processes_submit_exception.py:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"from concurrent.futures import ProcessPoolExecutor, as_completed\nfrom pprint import pprint\nfrom datetime import datetime\nimport time\nfrom itertools import repeat\nimport logging\n\nimport yaml\nfrom netmiko import ConnectHandler\nfrom netmiko.ssh_exception import NetMikoAuthenticationException\n\nlogging.getLogger(\"paramiko\").setLevel(logging.WARNING)\n\nlogging.basicConfig(\n    format = '%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO)\n\nstart_msg = '===> {} Connection: {}'\nreceived_msg = '<=== {} Received: {}'\n\n\ndef send_show(device_dict, command):\n    ip = device_dict['host']\n    logging.info(start_msg.format(datetime.now().time(), ip))\n    if ip == '192.168.100.1': time.sleep(5)\n    with ConnectHandler(**device_dict) as ssh:\n        ssh.enable()\n        result = ssh.send_command(command)\n        logging.info(received_msg.format(datetime.now().time(), ip))\n    return {ip: result}\n\n\ndef send_command_to_devices(devices, command):\n    data = {}\n    with ProcessPoolExecutor(max_workers=2) as executor:\n        future_ssh = [\n            executor.submit(send_show, device, command) for device in devices\n        ]\n        for f in as_completed(future_ssh):\n            try:\n                result = f.result()\n            except NetMikoAuthenticationException as e:\n                print(e)\n            else:\n                data.update(result)\n    return data\n\n\nif __name__ == '__main__':\n    with open('devices.yaml') as f:\n        devices = yaml.safe_load(f)\n    pprint(send_command_to_devices(devices, 'sh clock'))\n")),Object(r.b)("p",null,"Result of execution:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"$ python netmiko_processes_submit_exception.py\nMainThread root INFO: ===> 08:38:08.780267 Connection: 192.168.100.1\nMainThread root INFO: ===> 08:38:08.781355 Connection: 192.168.100.2\nMainThread root INFO: <=== 08:38:14.420339 Received: 192.168.100.2\nMainThread root INFO: ===> 08:38:14.529405 Connection: 192.168.100.3\nMainThread root INFO: <=== 08:38:19.224554 Received: 192.168.100.1\nMainThread root INFO: <=== 08:38:20.162920 Received: 192.168.100.3\n{'192.168.100.1': '*08:38:19.058 UTC Fri Jul 26 2019',\n '192.168.100.2': '*08:38:14.250 UTC Fri Jul 26 2019',\n '192.168.100.3': '*08:38:19.995 UTC Fri Jul 26 2019'}\n")))}u.isMDXComponent=!0},281:function(e,n,t){"use strict";t.d(n,"a",(function(){return l})),t.d(n,"b",(function(){return b}));var o=t(0),i=t.n(o);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=i.a.createContext({}),u=function(e){var n=i.a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=u(e.components);return i.a.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,a=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),l=u(t),m=o,b=l["".concat(a,".").concat(m)]||l[m]||p[m]||r;return t?i.a.createElement(b,c(c({ref:n},d),{},{components:t})):i.a.createElement(b,c({ref:n},d))}));function b(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var d=2;d<r;d++)a[d]=t[d];return i.a.createElement.apply(null,a)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);