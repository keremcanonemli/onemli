(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{237:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return p}));var r=t(3),o=t(8),i=(t(0),t(281)),a={id:"search_function",title:"Search Function",sidebar_label:"Search Function",slug:"search_function",custom_edit_url:null},l={unversionedId:"python/15_module_re/search_function",id:"python/15_module_re/search_function",isDocsHomePage:!1,title:"Search Function",description:"Function search:",source:"@site/docs/python/15_module_re/3_search_function.md",slug:"/python/15_module_re/search_function",permalink:"/docs/python/15_module_re/search_function",editUrl:null,version:"current",sidebar_label:"Search Function",sidebar:"someSidebar",previous:{title:"Match Object",permalink:"/docs/python/15_module_re/match_object"},next:{title:"Match Function",permalink:"/docs/python/15_module_re/match_function"}},c=[{value:"Processing of \u2018show cdp neighbors detail\u2019 output",id:"processing-of-show-cdp-neighbors-detail-output",children:[]}],s={toc:c};function p(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Function ",Object(i.b)("inlineCode",{parentName:"p"},"search"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"is used to find a substring that matches a template"),Object(i.b)("li",{parentName:"ul"},"returns Match object if a substring is found"),Object(i.b)("li",{parentName:"ul"},"returns ",Object(i.b)("inlineCode",{parentName:"li"},"None")," if no substring was found")),Object(i.b)("p",null,"Function ",Object(i.b)("inlineCode",{parentName:"p"},"search")," is suitable when you need to find only one match in a string, for example when a regex describes the entire string or part of a string."),Object(i.b)("p",null,"Consider an example of using ",Object(i.b)("inlineCode",{parentName:"p"},"search")," function to parse a log file. File log.txt contains log messages indicating that the same MAC is too often re-learned on one or another interface. One of the reasons for these messages is loop in network."),Object(i.b)("p",null,"Contents of log.txt file:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"%SW_MATM-4-MACFLAP_NOTIF: Host 01e2.4c18.0156 in vlan 10 is flapping between port Gi0/16 and port Gi0/24\n%SW_MATM-4-MACFLAP_NOTIF: Host 01e2.4c18.0156 in vlan 10 is flapping between port Gi0/16 and port Gi0/24\n%SW_MATM-4-MACFLAP_NOTIF: Host 01e2.4c18.0156 in vlan 10 is flapping between port Gi0/24 and port Gi0/19\n%SW_MATM-4-MACFLAP_NOTIF: Host 01e2.4c18.0156 in vlan 10 is flapping between port Gi0/24 and port Gi0/16\n")),Object(i.b)("p",null,"MAC address can jump between several ports. In this case it is very important to know from which ports MAC comes."),Object(i.b)("p",null,"Try to figure out which ports and which VLAN was the problem. Check regex with one line from log file:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [1]: import re\n\nIn [2]: log = '%SW_MATM-4-MACFLAP_NOTIF: Host 01e2.4c18.0156 in vlan 10 is flapping between port Gi0/16 and port Gi0/24'\n\nIn [3]: match = re.search(r'Host \\S+ '\n   ...:                   r'in vlan (\\d+) '\n   ...:                   r'is flapping between port '\n   ...:                   r'(\\S+) and port (\\S+)', log)\n   ...:\n")),Object(i.b)("p",null,"Regex is divided into parts for ease of reading. It has three groups:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"(\\d+)")," - describes VLAN number"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"(\\S+) and port (\\S+)")," - describes port numbers")),Object(i.b)("p",null,"As a result, the following parts of line fell into the groups:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-python"},"In [4]: match.groups()\nOut[4]: ('10', 'Gi0/16', 'Gi0/24')\n")),Object(i.b)("p",null,"In the resulting script, log.txt is processed line by line and port information is collected from each line. Since ports can be duplicated we add them immediately to the set in order to get a compilation of unique interfaces (parse_log_search.py file):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import re\n\nregex = ('Host \\S+ '\n         'in vlan (\\d+) '\n         'is flapping between port '\n         '(\\S+) and port (\\S+)')\n\nports = set()\n\nwith open('log.txt') as f:\n    for line in f:\n        match = re.search(regex, line)\n        if match:\n            vlan = match.group(1)\n            ports.add(match.group(2))\n            ports.add(match.group(3))\n\nprint('\u041f\u0435\u0442\u043b\u044f \u043c\u0435\u0436\u0434\u0443 \u043f\u043e\u0440\u0442\u0430\u043c\u0438 {} \u0432 VLAN {}'.format(', '.join(ports), vlan))\n")),Object(i.b)("p",null,"The result of script execution:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"$ python parse_log_search.py\nLoop between ports Gi0/19, Gi0/24, Gi0/16 \u0432 VLAN 10\n")),Object(i.b)("h2",{id:"processing-of-show-cdp-neighbors-detail-output"},"Processing of \u2018show cdp neighbors detail\u2019 output"),Object(i.b)("p",null,"Try to get device parameters from \u2018sh cdp neighbors detail\u2019 output."),Object(i.b)("p",null,"Example of output for one neighbor:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"SW1#show cdp neighbors detail\n-------------------------\nDevice ID: SW2\nEntry address(es):\n  IP address: 10.1.1.2\nPlatform: cisco WS-C2960-8TC-L,  Capabilities: Switch IGMP\nInterface: GigabitEthernet1/0/16,  Port ID (outgoing port): GigabitEthernet0/1\nHoldtime : 164 sec\n\nVersion :\nCisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9, RELEASE SOFTWARE (fc1)\nTechnical Support: http://www.cisco.com/techsupport\nCopyright (c) 1986-2014 by Cisco Systems, Inc.\nCompiled Mon 03-Mar-14 22:53 by prod_rel_team\n\nadvertisement version: 2\nVTP Management Domain: ''\nNative VLAN: 1\nDuplex: full\nManagement address(es):\n  IP address: 10.1.1.2\n")),Object(i.b)("p",null,"The goal is to get such fields:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"neighbor name (Device ID: SW2)"),Object(i.b)("li",{parentName:"ul"},"IP address of neighbor (IP address: 10.1.1.2)"),Object(i.b)("li",{parentName:"ul"},"neighbor platform (Platform: cisco WS-C2960-8TC-L)"),Object(i.b)("li",{parentName:"ul"},"IOS version (Cisco IOS Software, C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9, RELEASE SOFTWARE (fc1))")),Object(i.b)("p",null,"And for convenience you need to get data in the form of a dictionary. Example of the resulting dictionary for SW2 switch:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"{'SW2': {'ip': '10.1.1.2',\n         'platform': 'cisco WS-C2960-8TC-L',\n         'ios': 'C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9'}}\n")),Object(i.b)("p",null,"Example is checked on file sh_cdp_neighbors_sw1.txt."),Object(i.b)("p",null,"The first solution (parse_sh_cdp_neighbors_detail_ver1.py file):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import re\nfrom pprint import pprint\n\n\ndef parse_cdp(filename):\n    result = {}\n\n    with open(filename) as f:\n        for line in f:\n            if line.startswith('Device ID'):\n                neighbor = re.search('Device ID: (\\S+)', line).group(1)\n                result[neighbor] = {}\n            elif line.startswith('  IP address'):\n                ip = re.search('IP address: (\\S+)', line).group(1)\n                result[neighbor]['ip'] = ip\n            elif line.startswith('Platform'):\n                platform = re.search('Platform: (\\S+ \\S+),', line).group(1)\n                result[neighbor]['platform'] = platform\n            elif line.startswith('Cisco IOS Software'):\n                ios = re.search('Cisco IOS Software, (.+), RELEASE',\n                                line).group(1)\n                result[neighbor]['ios'] = ios\n\n    return result\n\n\npprint(parse_cdp('sh_cdp_neighbors_sw1.txt'))\n")),Object(i.b)("p",null,"The desired strings are selected using startswith() string method. And in a string, a regex takes required part of the string. It all ends up in a dictionary."),Object(i.b)("p",null,"The result is:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"$ python parse_sh_cdp_neighbors_detail_ver1.py\n{'R1': {'ios': '3800 Software (C3825-ADVENTERPRISEK9-M), Version 12.4(24)T1',\n        'ip': '10.1.1.1',\n        'platform': 'Cisco 3825'},\n 'R2': {'ios': '2900 Software (C3825-ADVENTERPRISEK9-M), Version 15.2(2)T1',\n        'ip': '10.2.2.2',\n        'platform': 'Cisco 2911'},\n 'SW2': {'ios': 'C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9',\n         'ip': '10.1.1.2',\n         'platform': 'cisco WS-C2960-8TC-L'}}\n")),Object(i.b)("p",null,"It worked out well, but it can be done in a more compact way."),Object(i.b)("p",null,"The second version of solution (parse_sh_cdp_neighbors_detail_ver2.py file):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"import re\nfrom pprint import pprint\n\n\ndef parse_cdp(filename):\n    regex = ('Device ID: (?P<device>\\S+)'\n             '|IP address: (?P<ip>\\S+)'\n             '|Platform: (?P<platform>\\S+ \\S+),'\n             '|Cisco IOS Software, (?P<ios>.+), RELEASE')\n\n    result = {}\n\n    with open(filename) as f:\n        for line in f:\n            match = re.search(regex, line)\n            if match:\n                if match.lastgroup == 'device':\n                    device = match.group(match.lastgroup)\n                    result[device] = {}\n                elif device:\n                    result[device][match.lastgroup] = match.group(\n                        match.lastgroup)\n\n    return result\n\n\npprint(parse_cdp('sh_cdp_neighbors_sw1.txt'))\n")),Object(i.b)("p",null,"Explanations for the second option:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"in regex, all lines written via ",Object(i.b)("inlineCode",{parentName:"li"},"|")," sign (or)"),Object(i.b)("li",{parentName:"ul"},"if a match is found, ",Object(i.b)("inlineCode",{parentName:"li"},"lastgroup")," method is checked"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"lastgroup")," method returns name of the last named group in regex for which a match has been found"),Object(i.b)("li",{parentName:"ul"},"if a match was found for ",Object(i.b)("inlineCode",{parentName:"li"},"device")," group, the value that fells into the group is written to ",Object(i.b)("inlineCode",{parentName:"li"},"device")," variable"),Object(i.b)("li",{parentName:"ul"},"otherwise the mapping of ",Object(i.b)("inlineCode",{parentName:"li"},"'group name': 'corresponding value'")," is written to dictionary")),Object(i.b)("p",null,"Result will be the same:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"$ python parse_sh_cdp_neighbors_detail_ver2.py\n{'R1': {'ios': '3800 Software (C3825-ADVENTERPRISEK9-M), Version 12.4(24)T1',\n        'ip': '10.1.1.1',\n        'platform': 'Cisco 3825'},\n 'R2': {'ios': '2900 Software (C3825-ADVENTERPRISEK9-M), Version 15.2(2)T1',\n        'ip': '10.2.2.2',\n        'platform': 'Cisco 2911'},\n 'SW2': {'ios': 'C2960 Software (C2960-LANBASEK9-M), Version 12.2(55)SE9',\n         'ip': '10.1.1.2',\n         'platform': 'cisco WS-C2960-8TC-L'}}\n")))}p.isMDXComponent=!0},281:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return f}));var r=t(0),o=t.n(r);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=o.a.createContext({}),p=function(e){var n=o.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return o.a.createElement(s.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},d=o.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=p(t),d=r,f=u["".concat(a,".").concat(d)]||u[d]||b[d]||i;return t?o.a.createElement(f,l(l({ref:n},s),{},{components:t})):o.a.createElement(f,l({ref:n},s))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var s=2;s<i;s++)a[s]=t[s];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);